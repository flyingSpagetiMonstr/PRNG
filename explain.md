# Preliminaries
### PRNG可以看作一个状态机
  - 给定状态机初态`state`，则PRNG的工作过程可以被描述为：
    ```python
    while(1):
        out = g(state)
        state = update(state)
        yield out
    ```
  - `update`每次改变/更新`state`，`g`从`state`中提出信息（`out`）作为输出
  - 关键在于更新函数的设计/结构

### 理想的PRNG应具有以下性质
1. 保证Uniformity，即零和一出现的概率相等
2. 避免短周期（收敛），理想情况下，状态应具有遍历性
3. 复杂性
   - 采用足够复杂（难以被识别）的结构，使生成的比特流呈现伪无规律
   - 本程序中通过对`update()`的设计达到上述目标，即：经过足够多（复杂）的变换，使新状态（下一状态）和旧状态（当前状态）之间呈现伪独立性
- 更新：最近搜了几篇PRNG相关的论文，发现这描述的基本就是混沌系统的性质，而且在知网搜伪随机数生成器，搜到的大多都是基于混沌系统，被降维打击了T-T

### 函数/映射选取
  - 伪随机数生成算法很关键的一点是复杂度，若不在乎复杂度，大可计算 $e^{x}$， $x$ 作为种子， $e^{x}$ 的二进制表示作为输出流，也会有不错的结果(参考测试集中`.\data\data.e`、`.\data\data.pi`等)
  - 因此设计中使用计算机原生的运算、操作作为映射，按结构可分为：
    1. 各种算术运算，结构简单的数据到数据映射
       - `add`
       - `xor (bitwise)`
       - `cyclic shift`
       - `not (bitwise)`
    2. 其它不能保持Uniformity的算术运算(不采用为主干运算，仅作辅助)<a id="f-02-back"></a>[[See more @f-02]](#f-02)
       - `multiply`
       - `and (bitwise)`
       - `or (bitwise)`
    3. 数据映射到数据，将数据解释为数据的地址，化数组为映射
       - `x = f[x]`
    4. 数据映射到操作，将数据解释为指令的地址：跳转表
       - `operation = operations[x]`

### [Coupon collector's problem](https://en.wikipedia.org/wiki/Coupon_collector%27s_problem)
   - 每次从1 ~ n随机取1个值，平均需要取多少次才能遍历1 ~ n？
   - 问题的解由以下公式给出：<br>
   $E[n] = n \cdot \left(1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n}\right)$

# Procedure
### note
- 建议参考代码阅读

### `state`、`g`的选取
  - 状态主体选择为一个数组`uint8_t f[256]`，这样状态本身除了可以看作数据，同时可以看作一个 $[0, 256]->[0, 256]$ 的映射。此外，状态还包含`uint8_t i`、[`uint16_t x`]
  - `f[i]`作为每次迭代的输出
  - 每次输出后更新`f[i]`、`i`、`x`

### `update`的设计
  - 核心
    - `phi`为函数指针数组，存有`{add, xor, rshitf, unarys}`四个双目运算
      - `rshift`为循环移位
      - `unarys`中有两个单目运算，用第二个操作数来选择对第一个操作数进行哪个单目运算
    - 三次`PHI`
      - 以`b = PHI(c)(b, f[a])`为例，用`c`选择实施的运算，`b`作主操作数，`f[c]`作副操作数，运算结果赋给`b`
      - 每次循环中将`a`、`b`、`c`轮换位置参与变换
      - 同时`a`除了自更新时，均以`f[a]`形式参与变换
    - 循环22次后，取`a`值作为新`f[i]`
      - 为什么循环22次？$E[8] = 21.742857 \approx 22$
    - 总体上，这里一系列操作交叉使用了之前提到的[所有方法](#函数映射选取)
  - 其它
    1. 参见[`state->x`](#state-x)
    2. 最后，若`f[]`新值和原值相等，则`+=1`<a id="f-01-back"></a>[[See more @f-01]](#f-01)

### `state->x`
  - `x`为常量偏移，在每次update时也会自更新一次，主要作用是防止输出过分依赖`f[]`，`x`可以让`f[]`更快地从有序状态（比如全零）恢复到伪随机状态。
  - 设计上采用最大原根每次作乘法遍历`P=1567`的简化剩余系(1~1566)
  - 为什么`P=1567`？
    - `x`除了直接作常量偏移，也以`c = f[COMPRESS(state->x)]`等用法来进行“三次`PHI`”前[`a`、`b`、`c`的初始化](#abc的初始化)，故需要有较长的周期，避免因周期过短在`f[]`未充分更新时即开始循环，会导致`f[x]`出现周期性
    - 理想情况下，`x`的周期应长于`f[]`全部更新一遍所需的轮数，而每次迭代，`f[]`的哪个元素会被更新可以看作随机的
    - $E[256] = 1567.832310$，取最近的素数即得1567
  - 为什么取最大原根？
    - 每次乘的数更大可以在模`P`后有更好的Uniformity

### `a`、`b`、`c`的初始化
- PRNG的每次更新所使用的参数中，必然包含之前步骤所得出的“新”值
- `a`直接取`state->i`，`b`和`c`则使用了[`state->x`](#state-xsee-code)和`f[]`

### 其它
- 更新`state->i`
  ```c
  i_new = PHI(a)(old^(state->i), (b^c)|1); // mask out unarys:f
  ```
- `f[]`的额外修改 
  ```c
  uint8_t B = 0, C = 0;
  B = PHI(a)(f[b], c|1);
  C = PHI(a)(f[c], b|1);
  f[b] = C;
  f[c] = B;
  ```

# 其它
### 一、这个PRNG的种子是什么？
可以取`*state`中的任意位作种子，其余位按`default_state`即可。建议优先取`i`作种子，其次是`x`，最后`f[]`。

虽然算法本身有回正能力，但仍推荐用随机源给 `f[]` 一个较好的初态。

### 二、是否是CSPRNG
CSPRNG: Cryptographically secure pseudorandom number generator

CSPRNG要求
1. 由当前的部分/全部状态不能倒推之前的状态/输出
2. 通过[Next-bit test](https://en.wikipedia.org/wiki/Next-bit_test)，即在已知前N位输出的情况下，无法据此预测下一位输出。

#### 状态无法反推
- `f[]`为一个用完即弃（因为每轮会更新）的映射，且`f[]`在完全伪随机时还具有非线性、不可逆（非满射）的性质（`f[]`在更新过程中经过线性或满射状态的频率极低）
  - 若`f[]`未被赋种，则由有序的初态到完全伪随机状态的期望轮数为更新255个元素所需的轮数，即略小于 $E[256]$ ，到达该轮数之前的输出可以考虑舍弃。
- `update()`以上述方式更新`state`，使得计算 $update(state)$ 简单，计算 $update^{-1}(state)$ 只能靠尝试与验证，且 $update()$ 不一定是可逆函数，故由当前状态无法倒推之前状态，也就无法获得之前的输出

#### 能否通过Next-bit test
这个要求其实是对PRNG的要求，是能通过随机性检测程序的充分条件
1. 统计上，该程序可以通过NIST测试集
2. 算法结构上，分析有：
   1. 程序每次输出`f[]`在`i`处的值，攻击者每次获知当前状态下`f[]`中的一个值，但不知道是`f[]`第几个元素的值
   2. 欲预测下次输出，需知道当前`f[i]`和`i`
   3. `i`是在上一轮中通过`update()`计算得到，计算过程中使用了整个`*state`，欲知`i`，需先知`i`、`x`、映射`f[]`，而攻击者最理想的情况下也只能知道乱序的`f[]`，想要知道有序的`f[]`，必须掌握每次的`i`
   4. 形成死锁，故无法直接预测下一位输出

<!-- ================================================== -->

# Footnotes
## f-02
- 此程序按整数输出，一次输出一个`uint8_t`，主要操作也是在`uint8_t`上进行
- 以双目运算为例，运算对象是`uint8_t`的情况下，很多双目运算在两个操作数完全随机（均匀）时，输出是不均匀的
  - 比如，最好理解的是移位运算，丢弃移出位，新位补0，总是会增加0的个数
  - 其它很明显的有除法、取模、按位与、按位或等等
  - 经测试，乘法、以50%概率选择进行“按位与”或“按位或”都不符合，测试代码可参考：
    ```c
    for (int i = 0; i < 256; i++)
    {
        for (int j = 0; j < 256; j++)
        {
            sum[(uint8_t)(i & j)]++;
            sum[(uint8_t)(i | j)]++;
        }
    }
    for (int index = 0; index < 256; index++)
    {
        cout << index << ": " << sum[index] << endl;
    }
    ```
    最后检查sum数组中值是不是全相等即可（当然也可以不借助程序直接用概率论来算，但这样快一些）
[Go back](#f-02-back)
